{"ast":null,"code":"import { getBsVer } from 'ngx-bootstrap/utils';\nimport { ɵɵdefineInjectable, ɵɵinject, NgZone, RendererFactory2, PLATFORM_ID, Injectable, Inject, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\nimport * as ɵngcc0 from '@angular/core';\nvar MapPlacementInToRL;\n(function (MapPlacementInToRL) {\n  MapPlacementInToRL[\"top\"] = \"top\";\n  MapPlacementInToRL[\"bottom\"] = \"bottom\";\n  MapPlacementInToRL[\"left\"] = \"left\";\n  MapPlacementInToRL[\"right\"] = \"right\";\n  MapPlacementInToRL[\"auto\"] = \"auto\";\n  MapPlacementInToRL[\"end\"] = \"right\";\n  MapPlacementInToRL[\"start\"] = \"left\";\n  MapPlacementInToRL[\"top left\"] = \"top left\";\n  MapPlacementInToRL[\"top right\"] = \"top right\";\n  MapPlacementInToRL[\"right top\"] = \"right top\";\n  MapPlacementInToRL[\"right bottom\"] = \"right bottom\";\n  MapPlacementInToRL[\"bottom right\"] = \"bottom right\";\n  MapPlacementInToRL[\"bottom left\"] = \"bottom left\";\n  MapPlacementInToRL[\"left bottom\"] = \"left bottom\";\n  MapPlacementInToRL[\"left top\"] = \"left top\";\n  MapPlacementInToRL[\"top start\"] = \"top left\";\n  MapPlacementInToRL[\"top end\"] = \"top right\";\n  MapPlacementInToRL[\"end top\"] = \"right top\";\n  MapPlacementInToRL[\"end bottom\"] = \"right bottom\";\n  MapPlacementInToRL[\"bottom end\"] = \"bottom right\";\n  MapPlacementInToRL[\"bottom start\"] = \"bottom left\";\n  MapPlacementInToRL[\"start bottom\"] = \"start bottom\";\n  MapPlacementInToRL[\"start top\"] = \"left top\";\n})(MapPlacementInToRL || (MapPlacementInToRL = {}));\nvar PlacementForBs5;\n(function (PlacementForBs5) {\n  PlacementForBs5[\"top\"] = \"top\";\n  PlacementForBs5[\"bottom\"] = \"bottom\";\n  PlacementForBs5[\"left\"] = \"start\";\n  PlacementForBs5[\"right\"] = \"end\";\n  PlacementForBs5[\"auto\"] = \"auto\";\n  PlacementForBs5[\"end\"] = \"end\";\n  PlacementForBs5[\"start\"] = \"start\";\n  PlacementForBs5[\"top left\"] = \"top start\";\n  PlacementForBs5[\"top right\"] = \"top end\";\n  PlacementForBs5[\"right top\"] = \"end top\";\n  PlacementForBs5[\"right bottom\"] = \"end bottom\";\n  PlacementForBs5[\"bottom right\"] = \"bottom end\";\n  PlacementForBs5[\"bottom left\"] = \"bottom start\";\n  PlacementForBs5[\"left bottom\"] = \"start bottom\";\n  PlacementForBs5[\"left top\"] = \"start top\";\n  PlacementForBs5[\"top start\"] = \"top start\";\n  PlacementForBs5[\"top end\"] = \"top end\";\n  PlacementForBs5[\"end top\"] = \"end top\";\n  PlacementForBs5[\"end bottom\"] = \"end bottom\";\n  PlacementForBs5[\"bottom end\"] = \"bottom end\";\n  PlacementForBs5[\"bottom start\"] = \"bottom start\";\n  PlacementForBs5[\"start bottom\"] = \"start bottom\";\n  PlacementForBs5[\"start top\"] = \"start top\";\n})(PlacementForBs5 || (PlacementForBs5 = {}));\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const css = window === null || window === void 0 ? void 0 : window.getComputedStyle(element, null);\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return property ? css && css[property] : css;\n}\nconst isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n/**\n * Determines if the browser is Internet Explorer\n */\n// todo: valorkin fix and drop IE support :evil:\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nconst isIE10 = isBrowser && !!(window.MSInputMethodContext && /MSIE 10/.test(navigator.userAgent));\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n  const noOffsetParent = isIE(10) ? document.body : null;\n  // NOTE: 1 DOM access here\n  let offsetParent = element === null || element === void 0 ? void 0 : element.offsetParent;\n  // Skip hidden elements which don't have an offsetParent\n  let sibling = void 0;\n  while (offsetParent === noOffsetParent && element.nextElementSibling && sibling !== element.nextElementSibling) {\n    // todo: valorkin fix\n    sibling = element.nextElementSibling;\n    offsetParent = sibling.offsetParent;\n  }\n  const nodeName = offsetParent && offsetParent.nodeName;\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  }\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  if (offsetParent && ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n  return offsetParent;\n}\n\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isOffsetContainer(element) {\n  const {\n    nodeName\n  } = element;\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n  // Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  // todo: valorkin fix\n  const commonAncestorContainer = range.commonAncestorContainer;\n  // Both nodes are inside #document\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n    return getOffsetParent(commonAncestorContainer);\n  }\n  // one of the nodes is inside shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n */\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  let el = element.parentElement;\n  while ((el === null || el === void 0 ? void 0 : el.parentElement) && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Helper to detect borders of a given element\n */\nfunction getBordersSize(styles, axis) {\n  const sideA = axis === 'x' ? 'Left' : 'Top';\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n  return parseFloat(styles[`border${sideA}Width`]) + parseFloat(styles[`border${sideB}Width`]);\n}\nfunction getSize(axis, body, html, computedStyle) {\n  const _body = body;\n  const _html = html;\n  const _computedStyle = computedStyle;\n  return Math.max(_body[`offset${axis}`], _body[`scroll${axis}`], _html[`client${axis}`], _html[`offset${axis}`], _html[`scroll${axis}`], isIE(10) ? parseInt(_html[`offset${axis}`], 10) + parseInt(_computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`], 10) + parseInt(_computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`], 10) : 0);\n}\nfunction getWindowSizes(document) {\n  const body = document.body;\n  const html = document.documentElement;\n  const computedStyle = isIE(10) ? getComputedStyle(html) : void 0;\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\nfunction getScroll(element, side = 'top') {\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  const nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    const html = element.ownerDocument.documentElement;\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n  return element[upperSide];\n}\nfunction getClientRect(offsets) {\n  return Object.assign(Object.assign({}, offsets), {\n    right: (offsets.left || 0) + offsets.width,\n    bottom: (offsets.top || 0) + offsets.height\n  });\n}\n\n/**\n * Tells if a given input is a number\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(Number(n));\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isNumber(value) {\n  return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\n/**\n * Get bounding client rect of given element\n */\nfunction getBoundingClientRect(element) {\n  const rect = element.getBoundingClientRect();\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      const scrollTop = getScroll(element, 'top');\n      const scrollLeft = getScroll(element, 'left');\n      if (rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right)) {\n        rect.top += scrollTop;\n        rect.left += scrollLeft;\n        rect.bottom += scrollTop;\n        rect.right += scrollLeft;\n      }\n    }\n  } catch (e) {\n    return rect;\n  }\n  if (!(rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right))) {\n    return rect;\n  }\n  const result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n  // subtract scrollbar size from sizes\n  const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : undefined;\n  const width = (sizes === null || sizes === void 0 ? void 0 : sizes.width) || element.clientWidth || isNumber(rect.right) && isNumber(result.left) && rect.right - result.left || 0;\n  const height = (sizes === null || sizes === void 0 ? void 0 : sizes.height) || element.clientHeight || isNumber(rect.bottom) && isNumber(result.top) && rect.bottom - result.top || 0;\n  let horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight - height;\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n  return getClientRect(result);\n}\n\n/**\n * Returns the parentNode or the host of the element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n    default:\n  }\n  // Firefox want us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n * Sum or subtract the element scroll values (left and top) from a given rect object\n */\nfunction includeScroll(rect, element, subtract = false) {\n  const scrollTop = getScroll(element, 'top');\n  const scrollLeft = getScroll(element, 'left');\n  const modifier = subtract ? -1 : 1;\n  if (isNumber(rect.top)) {\n    rect.top += scrollTop * modifier;\n  }\n  if (isNumber(rect.bottom)) {\n    rect.bottom += scrollTop * modifier;\n  }\n  if (isNumber(rect.left)) {\n    rect.left += scrollLeft * modifier;\n  }\n  if (isNumber(rect.right)) {\n    rect.right += scrollLeft * modifier;\n  }\n  return rect;\n}\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {\n  var _a, _b, _c, _d, _e, _f;\n  const isIE10 = isIE(10);\n  const isHTML = parent.nodeName === 'HTML';\n  const childrenRect = getBoundingClientRect(children);\n  const parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n  const styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max((_a = parentRect.top) !== null && _a !== void 0 ? _a : 0, 0);\n    parentRect.left = Math.max((_b = parentRect.left) !== null && _b !== void 0 ? _b : 0, 0);\n  }\n  let offsets = getClientRect({\n    top: ((_c = childrenRect.top) !== null && _c !== void 0 ? _c : 0) - ((_d = parentRect.top) !== null && _d !== void 0 ? _d : 0) - borderTopWidth,\n    left: ((_e = childrenRect.left) !== null && _e !== void 0 ? _e : 0) - ((_f = parentRect.left) !== null && _f !== void 0 ? _f : 0) - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n    if (isNumber(offsets.top)) {\n      offsets.top -= borderTopWidth - marginTop;\n    }\n    if (isNumber(offsets.bottom)) {\n      offsets.bottom -= borderTopWidth - marginTop;\n    }\n    if (isNumber(offsets.left)) {\n      offsets.left -= borderLeftWidth - marginLeft;\n    }\n    if (isNumber(offsets.right)) {\n      offsets.right -= borderLeftWidth - marginLeft;\n    }\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n  return offsets;\n}\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\n  const scrollTop = !excludeScroll ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n  const offset = {\n    top: scrollTop - Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.top) + Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.marginTop),\n    left: scrollLeft - Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.left) + Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.marginLeft),\n    width,\n    height\n  };\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n */\nfunction isFixed(element) {\n  const nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\nfunction getBoundaries(target, host, padding = 0, boundariesElement, fixedPosition = false) {\n  // NOTE: 1 DOM access here\n  let boundaries = {\n    top: 0,\n    left: 0\n  };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    let boundariesNode;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n    const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n    // In case of HTML, we need a different computation\n    if (offsets && boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      const {\n        height,\n        width\n      } = getWindowSizes(target.ownerDocument);\n      if (isNumber(boundaries.top) && isNumber(offsets.top) && isNumber(offsets.marginTop)) {\n        boundaries.top += offsets.top - offsets.marginTop;\n      }\n      if (isNumber(boundaries.top)) {\n        boundaries.bottom = Number(height) + Number(offsets.top);\n      }\n      if (isNumber(boundaries.left) && isNumber(offsets.left) && isNumber(offsets.marginLeft)) {\n        boundaries.left += offsets.left - offsets.marginLeft;\n      }\n      if (isNumber(boundaries.top)) {\n        boundaries.right = Number(width) + Number(offsets.left);\n      }\n    } else if (offsets) {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n  // Add paddings\n  if (isNumber(boundaries.left)) {\n    boundaries.left += padding;\n  }\n  if (isNumber(boundaries.top)) {\n    boundaries.top += padding;\n  }\n  if (isNumber(boundaries.right)) {\n    boundaries.right -= padding;\n  }\n  if (isNumber(boundaries.bottom)) {\n    boundaries.bottom -= padding;\n  }\n  return boundaries;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\nfunction getArea({\n  width,\n  height\n}) {\n  return width * height;\n}\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions = ['top', 'bottom', 'right', 'left'], boundariesElement = 'viewport', padding = 0) {\n  var _a, _b, _c, _d;\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n  const boundaries = getBoundaries(target, host, padding, boundariesElement);\n  const rects = {\n    top: {\n      width: (_a = boundaries.width) !== null && _a !== void 0 ? _a : 0,\n      height: refRect.top && boundaries.top ? refRect.top - boundaries.top : 0\n    },\n    right: {\n      width: boundaries.right && refRect.right ? boundaries.right - refRect.right : 0,\n      height: (_b = boundaries.height) !== null && _b !== void 0 ? _b : 0\n    },\n    bottom: {\n      width: (_c = boundaries.width) !== null && _c !== void 0 ? _c : 0,\n      height: boundaries.bottom && refRect.bottom ? boundaries.bottom - refRect.bottom : 0\n    },\n    left: {\n      width: refRect.left && boundaries.left ? refRect.left - boundaries.left : 0,\n      height: (_d = boundaries.height) !== null && _d !== void 0 ? _d : 0\n    }\n  };\n  const sortedAreas = Object.keys(rects).map(key => Object.assign(Object.assign({\n    key\n  }, rects[key]), {\n    area: getArea(rects[key])\n  })).sort((a, b) => b.area - a.area);\n  let filteredAreas = sortedAreas.filter(({\n    width,\n    height\n  }) => {\n    return width >= target.clientWidth && height >= target.clientHeight;\n  });\n  filteredAreas = filteredAreas.filter(position => {\n    return allowedPositions.some(allowedPosition => {\n      return allowedPosition === position.key;\n    });\n  });\n  const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n  const variation = placement.split(' ')[1];\n  // for tooltip on auto position\n  target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${getBsVer().isBs5 ? PlacementForBs5[computedPlacement] : computedPlacement}`);\n  return computedPlacement + (variation ? `-${variation}` : '');\n}\nfunction getOffsets(data) {\n  var _a, _b, _c, _d;\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor((_a = data.offsets.target.left) !== null && _a !== void 0 ? _a : 0),\n    top: Math.round((_b = data.offsets.target.top) !== null && _b !== void 0 ? _b : 0),\n    bottom: Math.round((_c = data.offsets.target.bottom) !== null && _c !== void 0 ? _c : 0),\n    right: Math.floor((_d = data.offsets.target.right) !== null && _d !== void 0 ? _d : 0)\n  };\n}\n\n/**\n * Get the opposite placement of the given one\n */\nfunction getOppositePlacement(placement) {\n  const hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n\n/**\n * Get the opposite placement variation of the given one\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n  return variation;\n}\nconst parse = (value, def = 0) => value ? parseFloat(value) : def;\nconst ɵ0 = parse;\nfunction getOuterSizes(element) {\n  const window = element.ownerDocument.defaultView;\n  const styles = window === null || window === void 0 ? void 0 : window.getComputedStyle(element);\n  const x = parse(styles === null || styles === void 0 ? void 0 : styles.marginTop) + parse(styles === null || styles === void 0 ? void 0 : styles.marginBottom);\n  const y = parse(styles === null || styles === void 0 ? void 0 : styles.marginLeft) + parse(styles === null || styles === void 0 ? void 0 : styles.marginRight);\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n\n/**\n * Get offsets to the reference element\n */\nfunction getReferenceOffsets(target, host, fixedPosition) {\n  const commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get offsets to the target\n */\nfunction getTargetOffsets(target, hostOffsets, position) {\n  var _a, _b, _c;\n  const placement = position.split(' ')[0];\n  // Get target node sizes\n  const targetRect = getOuterSizes(target);\n  // Add position, width and height to our offsets object\n  const targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  };\n  // depending by the target placement we have to compute its offsets slightly differently\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n  targetOffsets[mainSide] = ((_a = hostOffsets[mainSide]) !== null && _a !== void 0 ? _a : 0) + hostOffsets[measurement] / 2 - targetRect[measurement] / 2;\n  targetOffsets[secondarySide] = placement === secondarySide ? ((_b = hostOffsets[secondarySide]) !== null && _b !== void 0 ? _b : 0) - targetRect[secondaryMeasurement] : (_c = hostOffsets[getOppositePlacement(secondarySide)]) !== null && _c !== void 0 ? _c : 0;\n  return targetOffsets;\n}\nfunction isModifierEnabled(options, modifierName) {\n  var _a;\n  return !!((_a = options.modifiers[modifierName]) === null || _a === void 0 ? void 0 : _a.enabled);\n}\nconst availablePositions = {\n  top: ['top', 'top start', 'top end'],\n  bottom: ['bottom', 'bottom start', 'bottom end'],\n  start: ['start', 'start top', 'start bottom'],\n  end: ['end', 'end top', 'end bottom']\n};\nfunction checkPopoverMargin(placement, checkPosition) {\n  if (!getBsVer().isBs5) {\n    return false;\n  }\n  return availablePositions[checkPosition].includes(placement);\n}\nfunction checkMargins(placement) {\n  if (!getBsVer().isBs5) {\n    return '';\n  }\n  if (checkPopoverMargin(placement, 'end')) {\n    return 'ms-2';\n  }\n  if (checkPopoverMargin(placement, 'start')) {\n    return 'me-2';\n  }\n  if (checkPopoverMargin(placement, 'top')) {\n    return 'mb-2';\n  }\n  if (checkPopoverMargin(placement, 'bottom')) {\n    return 'mt-2';\n  }\n  return '';\n}\nfunction updateContainerClass(data, renderer) {\n  const target = data.instance.target;\n  let containerClass = target.className;\n  const dataPlacement = getBsVer().isBs5 ? PlacementForBs5[data.placement] : data.placement;\n  if (data.placementAuto) {\n    containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${dataPlacement}`);\n    containerClass = containerClass.replace(/ms-2|me-2|mb-2|mt-2/g, '');\n    containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${dataPlacement}`);\n    containerClass = containerClass.replace(/\\sauto/g, ` ${dataPlacement}`);\n    if (containerClass.indexOf('popover') !== -1) {\n      containerClass = containerClass + ' ' + checkMargins(dataPlacement);\n    }\n    if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n      containerClass += ' popover-auto';\n    }\n    if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n      containerClass += ' tooltip-auto';\n    }\n  }\n  containerClass = containerClass.replace(/left|right|top|bottom|end|start/g, `${dataPlacement.split(' ')[0]}`);\n  if (renderer) {\n    renderer.setAttribute(target, 'class', containerClass);\n    return;\n  }\n  target.className = containerClass;\n}\nfunction setStyles(element, styles, renderer) {\n  if (!element || !styles) {\n    return;\n  }\n  Object.keys(styles).forEach(prop => {\n    let unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    if (renderer) {\n      renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n      return;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    element.style[prop] = String(styles[prop]) + unit;\n  });\n}\nfunction arrow(data) {\n  var _a, _b, _c, _d, _e, _f;\n  let targetOffsets = data.offsets.target;\n  // if arrowElement is a string, suppose it's a CSS selector\n  const arrowElement = data.instance.target.querySelector('.arrow');\n  // if arrowElement is not found, don't run the modifier\n  if (!arrowElement) {\n    return data;\n  }\n  const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n  const len = isVertical ? 'height' : 'width';\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\n  const side = sideCapitalized.toLowerCase();\n  const altSide = isVertical ? 'left' : 'top';\n  const opSide = isVertical ? 'bottom' : 'right';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n  const placementVariation = data.placement.split(' ')[1];\n  // top/left side\n  if (((_a = data.offsets.host[opSide]) !== null && _a !== void 0 ? _a : 0) - arrowElementSize < ((_b = targetOffsets[side]) !== null && _b !== void 0 ? _b : 0)) {\n    targetOffsets[side] -= ((_c = targetOffsets[side]) !== null && _c !== void 0 ? _c : 0) - (((_d = data.offsets.host[opSide]) !== null && _d !== void 0 ? _d : 0) - arrowElementSize);\n  }\n  // bottom/right side\n  if (Number(data.offsets.host[side]) + Number(arrowElementSize) > ((_e = targetOffsets[opSide]) !== null && _e !== void 0 ? _e : 0)) {\n    targetOffsets[side] += Number(data.offsets.host[side]) + Number(arrowElementSize) - Number(targetOffsets[opSide]);\n  }\n  targetOffsets = getClientRect(targetOffsets);\n  // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n  const css = getStyleComputedProperty(data.instance.target);\n  const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]) || 0;\n  const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]) || 0;\n  // compute center of the target\n  let center;\n  if (!placementVariation) {\n    center = Number(data.offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n  } else {\n    const targetBorderRadius = parseFloat(css.borderRadius) || 0;\n    const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n    center = side === placementVariation ? Number(data.offsets.host[side]) + targetSideArrowOffset : Number(data.offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n  }\n  let sideValue = center - ((_f = targetOffsets[side]) !== null && _f !== void 0 ? _f : 0) - targetMarginSide - targetBorderSide;\n  // prevent arrowElement from being placed not contiguously to its target\n  sideValue = Math.max(Math.min(targetOffsets[len] - (arrowElementSize + 5), sideValue), 0);\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  data.instance.arrow = arrowElement;\n  return data;\n}\nfunction flip(data) {\n  data.offsets.target = getClientRect(data.offsets.target);\n  if (!isModifierEnabled(data.options, 'flip')) {\n    data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    return data;\n  }\n  const boundaries = getBoundaries(data.instance.target, data.instance.host, 0,\n  // padding\n  'viewport', false // positionFixed\n  );\n\n  let placement = data.placement.split(' ')[0];\n  let variation = data.placement.split(' ')[1] || '';\n  const offsetsHost = data.offsets.host;\n  const target = data.instance.target;\n  const host = data.instance.host;\n  const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n  const flipOrder = [placement, adaptivePosition];\n  flipOrder.forEach((step, index) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n    if (placement !== step || flipOrder.length === index + 1) {\n      return;\n    }\n    placement = data.placement.split(' ')[0];\n    // using floor because the host offsets may contain decimals we are not going to consider here\n    const overlapsRef = placement === 'left' && Math.floor((_a = data.offsets.target.right) !== null && _a !== void 0 ? _a : 0) > Math.floor((_b = data.offsets.host.left) !== null && _b !== void 0 ? _b : 0) || placement === 'right' && Math.floor((_c = data.offsets.target.left) !== null && _c !== void 0 ? _c : 0) < Math.floor((_d = data.offsets.host.right) !== null && _d !== void 0 ? _d : 0) || placement === 'top' && Math.floor((_e = data.offsets.target.bottom) !== null && _e !== void 0 ? _e : 0) > Math.floor((_f = data.offsets.host.top) !== null && _f !== void 0 ? _f : 0) || placement === 'bottom' && Math.floor((_g = data.offsets.target.top) !== null && _g !== void 0 ? _g : 0) < Math.floor((_h = data.offsets.host.bottom) !== null && _h !== void 0 ? _h : 0);\n    const overflowsLeft = Math.floor((_j = data.offsets.target.left) !== null && _j !== void 0 ? _j : 0) < Math.floor((_k = boundaries.left) !== null && _k !== void 0 ? _k : 0);\n    const overflowsRight = Math.floor((_l = data.offsets.target.right) !== null && _l !== void 0 ? _l : 0) > Math.floor((_m = boundaries.right) !== null && _m !== void 0 ? _m : 0);\n    const overflowsTop = Math.floor((_o = data.offsets.target.top) !== null && _o !== void 0 ? _o : 0) < Math.floor((_p = boundaries.top) !== null && _p !== void 0 ? _p : 0);\n    const overflowsBottom = Math.floor((_q = data.offsets.target.bottom) !== null && _q !== void 0 ? _q : 0) > Math.floor((_r = boundaries.bottom) !== null && _r !== void 0 ? _r : 0);\n    const overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n    // flip the variation if required\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    const flippedVariation = isVertical && variation === 'left' && overflowsLeft || isVertical && variation === 'right' && overflowsRight || !isVertical && variation === 'left' && overflowsTop || !isVertical && variation === 'right' && overflowsBottom;\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n      data.placement = placement + (variation ? ` ${variation}` : '');\n      data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    }\n  });\n  return data;\n}\nfunction initData(targetElement, hostElement, position, options) {\n  if (!targetElement || !hostElement) {\n    return;\n  }\n  const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n  if (!position.match(/^(auto)*\\s*(left|right|top|bottom|start|end)*$/) && !position.match(/^(left|right|top|bottom|start|end)*(?: (left|right|top|bottom|start|end))*$/)) {\n    position = 'auto';\n  }\n  const placementAuto = !!position.match(/auto/g);\n  // support old placements 'auto left|right|top|bottom'\n  let placement = position.match(/auto\\s(left|right|top|bottom|start|end)/) ? position.split(' ')[1] || 'auto' : position;\n  // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n  const matches = placement.match(/^(left|right|top|bottom|start|end)* ?(?!\\1)(left|right|top|bottom|start|end)?/);\n  if (matches) {\n    placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n  }\n  // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n  if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n    placement = 'auto';\n  }\n  placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n  const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n  return {\n    options: options || {\n      modifiers: {}\n    },\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: void 0\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: void 0\n    },\n    positionFixed: false,\n    placement,\n    placementAuto\n  };\n}\nfunction preventOverflow(data) {\n  var _a;\n  if (!isModifierEnabled(data.options, 'preventOverflow')) {\n    return data;\n  }\n  // NOTE: DOM access here\n  // resets the target Offsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n  const transformProp = 'transform';\n  const targetStyles = data.instance.target.style; // assignment to help minification\n  const {\n    top,\n    left,\n    [transformProp]: transform\n  } = targetStyles;\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n  const boundaries = getBoundaries(data.instance.target, data.instance.host, 0,\n  // padding\n  ((_a = data.options.modifiers.preventOverflow) === null || _a === void 0 ? void 0 : _a.boundariesElement) || 'scrollParent', false // positionFixed\n  );\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n  const order = ['left', 'right', 'top', 'bottom'];\n  const check = {\n    primary(placement) {\n      var _a, _b, _c, _d;\n      let value = data.offsets.target[placement];\n      // options.escapeWithReference\n      if (((_a = data.offsets.target[placement]) !== null && _a !== void 0 ? _a : 0) < ((_b = boundaries[placement]) !== null && _b !== void 0 ? _b : 0)) {\n        value = Math.max((_c = data.offsets.target[placement]) !== null && _c !== void 0 ? _c : 0, (_d = boundaries[placement]) !== null && _d !== void 0 ? _d : 0);\n      }\n      return {\n        [placement]: value\n      };\n    },\n    secondary(placement) {\n      var _a, _b, _c, _d, _e, _f, _g, _h;\n      const mainSide = placement === 'right' ? 'left' : 'top';\n      let value = data.offsets.target[mainSide];\n      // escapeWithReference\n      if (((_a = data.offsets.target[placement]) !== null && _a !== void 0 ? _a : 0) < ((_b = boundaries[placement]) !== null && _b !== void 0 ? _b : 0) && placement !== 'right') {\n        value = Math.min((_c = data.offsets.target[mainSide]) !== null && _c !== void 0 ? _c : 0, ((_d = boundaries[placement]) !== null && _d !== void 0 ? _d : 0) - data.offsets.target.height);\n      }\n      if (((_e = data.offsets.target[placement]) !== null && _e !== void 0 ? _e : 0) > ((_f = boundaries[placement]) !== null && _f !== void 0 ? _f : 0) && placement === 'right') {\n        value = Math.min((_g = data.offsets.target[mainSide]) !== null && _g !== void 0 ? _g : 0, ((_h = boundaries[placement]) !== null && _h !== void 0 ? _h : 0) - data.offsets.target.width);\n      }\n      return {\n        [mainSide]: value\n      };\n    }\n  };\n  order.forEach(placement => {\n    const side = ['left', 'top', 'start'].indexOf(placement) !== -1 ? check['primary'] : check['secondary'];\n    data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), side(placement));\n  });\n  return data;\n}\nfunction shift(data) {\n  var _a;\n  const placement = data.placement;\n  const basePlacement = placement.split(' ')[0];\n  const shiftVariation = placement.split(' ')[1];\n  if (shiftVariation) {\n    const {\n      host,\n      target\n    } = data.offsets;\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n    const shiftOffsets = {\n      start: {\n        [side]: host[side]\n      },\n      end: {\n        [side]: ((_a = host[side]) !== null && _a !== void 0 ? _a : 0) + host[measurement] - target[measurement]\n      }\n    };\n    data.offsets.target = Object.assign(Object.assign({}, target), {\n      [side]: side === shiftVariation ? shiftOffsets.start[side] : shiftOffsets.end[side]\n    });\n  }\n  return data;\n}\nclass Positioning {\n  position(hostElement, targetElement /*, round = true*/) {\n    return this.offset(hostElement, targetElement /*, false*/);\n  }\n\n  offset(hostElement, targetElement /*, round = true*/) {\n    return getReferenceOffsets(targetElement, hostElement);\n  }\n  positionElements(hostElement, targetElement, position, appendToBody, options) {\n    const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n    const _position = MapPlacementInToRL[position];\n    const data = initData(targetElement, hostElement, _position, options);\n    if (!data) {\n      return;\n    }\n    return chainOfModifiers.reduce((modifiedData, modifier) => modifier(modifiedData), data);\n  }\n}\nconst positionService = new Positioning();\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n  const data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n  if (!data) {\n    return;\n  }\n  const offsets = getOffsets(data);\n  setStyles(targetElement, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n  }, renderer);\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n  updateContainerClass(data, renderer);\n}\nclass PositioningService {\n  constructor(ngZone, rendererFactory, platformId) {\n    this.update$$ = new Subject();\n    this.positionElements = new Map();\n    this.isDisabled = false;\n    if (isPlatformBrowser(platformId)) {\n      ngZone.runOutsideAngular(() => {\n        this.triggerEvent$ = merge(fromEvent(window, 'scroll', {\n          passive: true\n        }), fromEvent(window, 'resize', {\n          passive: true\n        }), of(0, animationFrameScheduler), this.update$$);\n        this.triggerEvent$.subscribe(() => {\n          if (this.isDisabled) {\n            return;\n          }\n          this.positionElements\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          .forEach(positionElement => {\n            positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, this.options, rendererFactory.createRenderer(null, null));\n          });\n        });\n      });\n    }\n  }\n  position(options) {\n    this.addPositionElement(options);\n  }\n  get event$() {\n    return this.triggerEvent$;\n  }\n  disable() {\n    this.isDisabled = true;\n  }\n  enable() {\n    this.isDisabled = false;\n  }\n  addPositionElement(options) {\n    this.positionElements.set(_getHtmlElement(options.element), options);\n  }\n  calcPosition() {\n    this.update$$.next();\n  }\n  deletePositionElement(elRef) {\n    this.positionElements.delete(_getHtmlElement(elRef));\n  }\n  setOptions(options) {\n    this.options = options;\n  }\n}\nPositioningService.ɵfac = function PositioningService_Factory(t) {\n  return new (t || PositioningService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2), ɵngcc0.ɵɵinject(PLATFORM_ID));\n};\nPositioningService.ɵprov = ɵɵdefineInjectable({\n  factory: function PositioningService_Factory() {\n    return new PositioningService(ɵɵinject(NgZone), ɵɵinject(RendererFactory2), ɵɵinject(PLATFORM_ID));\n  },\n  token: PositioningService,\n  providedIn: \"root\"\n});\nPositioningService.ctorParameters = () => [{\n  type: NgZone\n}, {\n  type: RendererFactory2\n}, {\n  type: Number,\n  decorators: [{\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PositioningService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.RendererFactory2\n    }, {\n      type: Number,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\nfunction _getHtmlElement(element) {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n  return element !== null && element !== void 0 ? element : null;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { PlacementForBs5, Positioning, PositioningService, checkMargins, positionElements };","map":{"version":3,"names":["getBsVer","ɵɵdefineInjectable","ɵɵinject","NgZone","RendererFactory2","PLATFORM_ID","Injectable","Inject","ElementRef","isPlatformBrowser","Subject","merge","fromEvent","of","animationFrameScheduler","ɵngcc0","MapPlacementInToRL","PlacementForBs5","getStyleComputedProperty","element","property","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","isBrowser","document","isIE11","MSInputMethodContext","documentMode","isIE10","test","navigator","userAgent","isIE","version","getOffsetParent","documentElement","noOffsetParent","body","offsetParent","sibling","nextElementSibling","nodeName","indexOf","isOffsetContainer","firstElementChild","getRoot","node","parentNode","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","host","getFixedPositionOffsetParent","parentElement","el","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","html","computedStyle","_body","_html","_computedStyle","Math","max","parseInt","getWindowSizes","height","width","getScroll","side","upperSide","scrollingElement","getClientRect","offsets","Object","assign","right","left","bottom","top","isNumeric","n","isNaN","isFinite","Number","isNumber","value","prototype","toString","call","getBoundingClientRect","rect","scrollTop","scrollLeft","e","result","sizes","undefined","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getParentNode","getScrollParent","overflow","overflowX","overflowY","String","includeScroll","subtract","modifier","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","_a","_b","_c","_d","_e","_f","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","offset","isFixed","getBoundaries","target","padding","boundariesElement","boundaries","boundariesNode","getArea","computeAutoPlacement","placement","refRect","allowedPositions","rects","sortedAreas","keys","map","key","area","sort","a","b","filteredAreas","filter","position","some","allowedPosition","computedPlacement","length","variation","split","className","replace","isBs5","getOffsets","data","floor","round","getOppositePlacement","hash","matched","getOppositeVariation","parse","def","ɵ0","getOuterSizes","x","marginBottom","y","marginRight","getReferenceOffsets","commonOffsetParent","getTargetOffsets","hostOffsets","targetRect","targetOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","isModifierEnabled","options","modifierName","modifiers","enabled","availablePositions","checkPopoverMargin","checkPosition","includes","checkMargins","updateContainerClass","renderer","instance","containerClass","dataPlacement","placementAuto","setAttribute","setStyles","forEach","prop","unit","setStyle","style","arrow","arrowElement","querySelector","isVertical","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","placementVariation","targetMarginSide","targetBorderSide","center","targetBorderRadius","borderRadius","targetSideArrowOffset","sideValue","min","flip","offsetsHost","adaptivePosition","flipOrder","step","index","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","initData","targetElement","hostElement","hostElPosition","match","matches","targetOffset","positionFixed","preventOverflow","transformProp","targetStyles","transform","check","primary","secondary","shift","basePlacement","shiftVariation","shiftOffsets","Positioning","positionElements","appendToBody","chainOfModifiers","_position","reduce","modifiedData","positionService","PositioningService","constructor","ngZone","rendererFactory","platformId","update$$","Map","isDisabled","runOutsideAngular","triggerEvent$","passive","subscribe","positionElement","_getHtmlElement","attachment","createRenderer","addPositionElement","event$","disable","enable","set","calcPosition","next","deletePositionElement","elRef","delete","setOptions","ɵfac","PositioningService_Factory","t","ɵprov","factory","token","providedIn","ctorParameters","type","decorators","args","ngDevMode","ɵsetClassMetadata","nativeElement"],"sources":["C:/Users/alexsander.da.silva/Documents/Projetos/Udemy/angularDotNet/proeventos/Front/ProEventos-App/node_modules/ngx-bootstrap/__ivy_ngcc__/positioning/fesm2015/ngx-bootstrap-positioning.js"],"sourcesContent":["import { getBsVer } from 'ngx-bootstrap/utils';\nimport { ɵɵdefineInjectable, ɵɵinject, NgZone, RendererFactory2, PLATFORM_ID, Injectable, Inject, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\n\nimport * as ɵngcc0 from '@angular/core';\nvar MapPlacementInToRL;\n(function (MapPlacementInToRL) {\n    MapPlacementInToRL[\"top\"] = \"top\";\n    MapPlacementInToRL[\"bottom\"] = \"bottom\";\n    MapPlacementInToRL[\"left\"] = \"left\";\n    MapPlacementInToRL[\"right\"] = \"right\";\n    MapPlacementInToRL[\"auto\"] = \"auto\";\n    MapPlacementInToRL[\"end\"] = \"right\";\n    MapPlacementInToRL[\"start\"] = \"left\";\n    MapPlacementInToRL[\"top left\"] = \"top left\";\n    MapPlacementInToRL[\"top right\"] = \"top right\";\n    MapPlacementInToRL[\"right top\"] = \"right top\";\n    MapPlacementInToRL[\"right bottom\"] = \"right bottom\";\n    MapPlacementInToRL[\"bottom right\"] = \"bottom right\";\n    MapPlacementInToRL[\"bottom left\"] = \"bottom left\";\n    MapPlacementInToRL[\"left bottom\"] = \"left bottom\";\n    MapPlacementInToRL[\"left top\"] = \"left top\";\n    MapPlacementInToRL[\"top start\"] = \"top left\";\n    MapPlacementInToRL[\"top end\"] = \"top right\";\n    MapPlacementInToRL[\"end top\"] = \"right top\";\n    MapPlacementInToRL[\"end bottom\"] = \"right bottom\";\n    MapPlacementInToRL[\"bottom end\"] = \"bottom right\";\n    MapPlacementInToRL[\"bottom start\"] = \"bottom left\";\n    MapPlacementInToRL[\"start bottom\"] = \"start bottom\";\n    MapPlacementInToRL[\"start top\"] = \"left top\";\n})(MapPlacementInToRL || (MapPlacementInToRL = {}));\nvar PlacementForBs5;\n(function (PlacementForBs5) {\n    PlacementForBs5[\"top\"] = \"top\";\n    PlacementForBs5[\"bottom\"] = \"bottom\";\n    PlacementForBs5[\"left\"] = \"start\";\n    PlacementForBs5[\"right\"] = \"end\";\n    PlacementForBs5[\"auto\"] = \"auto\";\n    PlacementForBs5[\"end\"] = \"end\";\n    PlacementForBs5[\"start\"] = \"start\";\n    PlacementForBs5[\"top left\"] = \"top start\";\n    PlacementForBs5[\"top right\"] = \"top end\";\n    PlacementForBs5[\"right top\"] = \"end top\";\n    PlacementForBs5[\"right bottom\"] = \"end bottom\";\n    PlacementForBs5[\"bottom right\"] = \"bottom end\";\n    PlacementForBs5[\"bottom left\"] = \"bottom start\";\n    PlacementForBs5[\"left bottom\"] = \"start bottom\";\n    PlacementForBs5[\"left top\"] = \"start top\";\n    PlacementForBs5[\"top start\"] = \"top start\";\n    PlacementForBs5[\"top end\"] = \"top end\";\n    PlacementForBs5[\"end top\"] = \"end top\";\n    PlacementForBs5[\"end bottom\"] = \"end bottom\";\n    PlacementForBs5[\"bottom end\"] = \"bottom end\";\n    PlacementForBs5[\"bottom start\"] = \"bottom start\";\n    PlacementForBs5[\"start bottom\"] = \"start bottom\";\n    PlacementForBs5[\"start top\"] = \"start top\";\n})(PlacementForBs5 || (PlacementForBs5 = {}));\n\nfunction getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    const window = element.ownerDocument.defaultView;\n    const css = window === null || window === void 0 ? void 0 : window.getComputedStyle(element, null);\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return property ? css && css[property] : css;\n}\n\nconst isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n/**\n * Determines if the browser is Internet Explorer\n */\n// todo: valorkin fix and drop IE support :evil:\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nconst isIE10 = isBrowser && !!(window.MSInputMethodContext && /MSIE 10/.test(navigator.userAgent));\nfunction isIE(version) {\n    if (version === 11) {\n        return isIE11;\n    }\n    if (version === 10) {\n        return isIE10;\n    }\n    return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n */\nfunction getOffsetParent(element) {\n    if (!element) {\n        return document.documentElement;\n    }\n    const noOffsetParent = isIE(10) ? document.body : null;\n    // NOTE: 1 DOM access here\n    let offsetParent = element === null || element === void 0 ? void 0 : element.offsetParent;\n    // Skip hidden elements which don't have an offsetParent\n    let sibling = void 0;\n    while (offsetParent === noOffsetParent\n        && element.nextElementSibling\n        && sibling !== element.nextElementSibling) {\n        // todo: valorkin fix\n        sibling = element.nextElementSibling;\n        offsetParent = sibling.offsetParent;\n    }\n    const nodeName = offsetParent && offsetParent.nodeName;\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n        return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n    }\n    // .offsetParent will return the closest TH, TD or TABLE in case\n    if (offsetParent &&\n        ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n        getStyleComputedProperty(offsetParent, 'position') === 'static') {\n        return getOffsetParent(offsetParent);\n    }\n    return offsetParent;\n}\n\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isOffsetContainer(element) {\n    const { nodeName } = element;\n    if (nodeName === 'BODY') {\n        return false;\n    }\n    return (nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element);\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\nfunction getRoot(node) {\n    if (node.parentNode !== null) {\n        return getRoot(node.parentNode);\n    }\n    return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n */\nfunction findCommonOffsetParent(element1, element2) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n        return document.documentElement;\n    }\n    // Here we make sure to give as \"start\" the element that comes first in the DOM\n    const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n    const start = order ? element1 : element2;\n    const end = order ? element2 : element1;\n    // Get common ancestor container\n    const range = document.createRange();\n    range.setStart(start, 0);\n    range.setEnd(end, 0);\n    // todo: valorkin fix\n    const commonAncestorContainer = range.commonAncestorContainer;\n    // Both nodes are inside #document\n    if ((element1 !== commonAncestorContainer &&\n        element2 !== commonAncestorContainer) ||\n        start.contains(end)) {\n        if (isOffsetContainer(commonAncestorContainer)) {\n            return commonAncestorContainer;\n        }\n        return getOffsetParent(commonAncestorContainer);\n    }\n    // one of the nodes is inside shadowDOM, find which one\n    const element1root = getRoot(element1);\n    if (element1root.host) {\n        return findCommonOffsetParent(element1root.host, element2);\n    }\n    else {\n        return findCommonOffsetParent(element1, getRoot(element2).host);\n    }\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n */\nfunction getFixedPositionOffsetParent(element) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element || !element.parentElement || isIE()) {\n        return document.documentElement;\n    }\n    let el = element.parentElement;\n    while ((el === null || el === void 0 ? void 0 : el.parentElement) && getStyleComputedProperty(el, 'transform') === 'none') {\n        el = el.parentElement;\n    }\n    return el || document.documentElement;\n}\n\n/**\n * Helper to detect borders of a given element\n */\nfunction getBordersSize(styles, axis) {\n    const sideA = axis === 'x' ? 'Left' : 'Top';\n    const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n    return (parseFloat(styles[`border${sideA}Width`]) +\n        parseFloat(styles[`border${sideB}Width`]));\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n    const _body = body;\n    const _html = html;\n    const _computedStyle = computedStyle;\n    return Math.max(_body[`offset${axis}`], _body[`scroll${axis}`], _html[`client${axis}`], _html[`offset${axis}`], _html[`scroll${axis}`], isIE(10)\n        ? (parseInt(_html[`offset${axis}`], 10) +\n            parseInt(_computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`], 10) +\n            parseInt(_computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`], 10))\n        : 0);\n}\nfunction getWindowSizes(document) {\n    const body = document.body;\n    const html = document.documentElement;\n    const computedStyle = isIE(10) ? getComputedStyle(html) : void 0;\n    return {\n        height: getSize('Height', body, html, computedStyle),\n        width: getSize('Width', body, html, computedStyle)\n    };\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\nfunction getScroll(element, side = 'top') {\n    const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        const html = element.ownerDocument.documentElement;\n        const scrollingElement = element.ownerDocument.scrollingElement || html;\n        return scrollingElement[upperSide];\n    }\n    return element[upperSide];\n}\n\nfunction getClientRect(offsets) {\n    return Object.assign(Object.assign({}, offsets), { right: (offsets.left || 0) + offsets.width, bottom: (offsets.top || 0) + offsets.height });\n}\n\n/**\n * Tells if a given input is a number\n */\nfunction isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(Number(n));\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isNumber(value) {\n    return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\n/**\n * Get bounding client rect of given element\n */\nfunction getBoundingClientRect(element) {\n    const rect = element.getBoundingClientRect();\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    try {\n        if (isIE(10)) {\n            const scrollTop = getScroll(element, 'top');\n            const scrollLeft = getScroll(element, 'left');\n            if (rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right)) {\n                rect.top += scrollTop;\n                rect.left += scrollLeft;\n                rect.bottom += scrollTop;\n                rect.right += scrollLeft;\n            }\n        }\n    }\n    catch (e) {\n        return rect;\n    }\n    if (!(rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right))) {\n        return rect;\n    }\n    const result = {\n        left: rect.left,\n        top: rect.top,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n    };\n    // subtract scrollbar size from sizes\n    const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : undefined;\n    const width = (sizes === null || sizes === void 0 ? void 0 : sizes.width) || element.clientWidth\n        || isNumber(rect.right) && isNumber(result.left) && rect.right - result.left || 0;\n    const height = (sizes === null || sizes === void 0 ? void 0 : sizes.height) || element.clientHeight\n        || isNumber(rect.bottom) && isNumber(result.top) && rect.bottom - result.top || 0;\n    let horizScrollbar = element.offsetWidth - width;\n    let vertScrollbar = element.offsetHeight - height;\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n        const styles = getStyleComputedProperty(element);\n        horizScrollbar -= getBordersSize(styles, 'x');\n        vertScrollbar -= getBordersSize(styles, 'y');\n        result.width -= horizScrollbar;\n        result.height -= vertScrollbar;\n    }\n    return getClientRect(result);\n}\n\n/**\n * Returns the parentNode or the host of the element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n        return element;\n    }\n    return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element) {\n        return document.body;\n    }\n    switch (element.nodeName) {\n        case 'HTML':\n        case 'BODY':\n            return element.ownerDocument.body;\n        case '#document':\n            return element.body;\n        default:\n    }\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n    if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n        return element;\n    }\n    return getScrollParent(getParentNode(element));\n}\n\n/**\n * Sum or subtract the element scroll values (left and top) from a given rect object\n */\nfunction includeScroll(rect, element, subtract = false) {\n    const scrollTop = getScroll(element, 'top');\n    const scrollLeft = getScroll(element, 'left');\n    const modifier = subtract ? -1 : 1;\n    if (isNumber(rect.top)) {\n        rect.top += scrollTop * modifier;\n    }\n    if (isNumber(rect.bottom)) {\n        rect.bottom += scrollTop * modifier;\n    }\n    if (isNumber(rect.left)) {\n        rect.left += scrollLeft * modifier;\n    }\n    if (isNumber(rect.right)) {\n        rect.right += scrollLeft * modifier;\n    }\n    return rect;\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {\n    var _a, _b, _c, _d, _e, _f;\n    const isIE10 = isIE(10);\n    const isHTML = parent.nodeName === 'HTML';\n    const childrenRect = getBoundingClientRect(children);\n    const parentRect = getBoundingClientRect(parent);\n    const scrollParent = getScrollParent(children);\n    const styles = getStyleComputedProperty(parent);\n    const borderTopWidth = parseFloat(styles.borderTopWidth);\n    const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n    // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n    if (fixedPosition && isHTML) {\n        parentRect.top = Math.max((_a = parentRect.top) !== null && _a !== void 0 ? _a : 0, 0);\n        parentRect.left = Math.max((_b = parentRect.left) !== null && _b !== void 0 ? _b : 0, 0);\n    }\n    let offsets = getClientRect({\n        top: ((_c = childrenRect.top) !== null && _c !== void 0 ? _c : 0) - ((_d = parentRect.top) !== null && _d !== void 0 ? _d : 0) - borderTopWidth,\n        left: ((_e = childrenRect.left) !== null && _e !== void 0 ? _e : 0) - ((_f = parentRect.left) !== null && _f !== void 0 ? _f : 0) - borderLeftWidth,\n        width: childrenRect.width,\n        height: childrenRect.height\n    });\n    offsets.marginTop = 0;\n    offsets.marginLeft = 0;\n    // Subtract margins of documentElement in case it's being used as parent\n    // we do this only on HTML because it's the only element that behaves\n    // differently when margins are applied to it. The margins are included in\n    // the box of the documentElement, in the other cases not.\n    if (!isIE10 && isHTML) {\n        const marginTop = parseFloat(styles.marginTop);\n        const marginLeft = parseFloat(styles.marginLeft);\n        if (isNumber(offsets.top)) {\n            offsets.top -= borderTopWidth - marginTop;\n        }\n        if (isNumber(offsets.bottom)) {\n            offsets.bottom -= borderTopWidth - marginTop;\n        }\n        if (isNumber(offsets.left)) {\n            offsets.left -= borderLeftWidth - marginLeft;\n        }\n        if (isNumber(offsets.right)) {\n            offsets.right -= borderLeftWidth - marginLeft;\n        }\n        // Attach marginTop and marginLeft because in some circumstances we may need them\n        offsets.marginTop = marginTop;\n        offsets.marginLeft = marginLeft;\n    }\n    if (isIE10 && !fixedPosition\n        ? parent.contains(scrollParent)\n        : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n        offsets = includeScroll(offsets, parent);\n    }\n    return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {\n    const html = element.ownerDocument.documentElement;\n    const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n    const width = Math.max(html.clientWidth, window.innerWidth || 0);\n    const height = Math.max(html.clientHeight, window.innerHeight || 0);\n    const scrollTop = !excludeScroll ? getScroll(html) : 0;\n    const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n    const offset = {\n        top: scrollTop - Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.top) + Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.marginTop),\n        left: scrollLeft - Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.left) + Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.marginLeft),\n        width,\n        height\n    };\n    return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n */\nfunction isFixed(element) {\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n\nfunction getBoundaries(target, host, padding = 0, boundariesElement, fixedPosition = false) {\n    // NOTE: 1 DOM access here\n    let boundaries = { top: 0, left: 0 };\n    const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    }\n    else {\n        // Handle other cases based on DOM element used as boundaries\n        let boundariesNode;\n        if (boundariesElement === 'scrollParent') {\n            boundariesNode = getScrollParent(getParentNode(host));\n            if (boundariesNode.nodeName === 'BODY') {\n                boundariesNode = target.ownerDocument.documentElement;\n            }\n        }\n        else if (boundariesElement === 'window') {\n            boundariesNode = target.ownerDocument.documentElement;\n        }\n        else {\n            boundariesNode = boundariesElement;\n        }\n        const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n        // In case of HTML, we need a different computation\n        if (offsets && boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n            const { height, width } = getWindowSizes(target.ownerDocument);\n            if (isNumber(boundaries.top) && isNumber(offsets.top) && isNumber(offsets.marginTop)) {\n                boundaries.top += offsets.top - offsets.marginTop;\n            }\n            if (isNumber(boundaries.top)) {\n                boundaries.bottom = Number(height) + Number(offsets.top);\n            }\n            if (isNumber(boundaries.left) && isNumber(offsets.left) && isNumber(offsets.marginLeft)) {\n                boundaries.left += offsets.left - offsets.marginLeft;\n            }\n            if (isNumber(boundaries.top)) {\n                boundaries.right = Number(width) + Number(offsets.left);\n            }\n        }\n        else if (offsets) {\n            // for all the other DOM elements, this one is good\n            boundaries = offsets;\n        }\n    }\n    // Add paddings\n    if (isNumber(boundaries.left)) {\n        boundaries.left += padding;\n    }\n    if (isNumber(boundaries.top)) {\n        boundaries.top += padding;\n    }\n    if (isNumber(boundaries.right)) {\n        boundaries.right -= padding;\n    }\n    if (isNumber(boundaries.bottom)) {\n        boundaries.bottom -= padding;\n    }\n    return boundaries;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\nfunction getArea({ width, height }) {\n    return width * height;\n}\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions = ['top', 'bottom', 'right', 'left'], boundariesElement = 'viewport', padding = 0) {\n    var _a, _b, _c, _d;\n    if (placement.indexOf('auto') === -1) {\n        return placement;\n    }\n    const boundaries = getBoundaries(target, host, padding, boundariesElement);\n    const rects = {\n        top: {\n            width: (_a = boundaries.width) !== null && _a !== void 0 ? _a : 0,\n            height: refRect.top && boundaries.top ? refRect.top - boundaries.top : 0\n        },\n        right: {\n            width: boundaries.right && refRect.right ? boundaries.right - refRect.right : 0,\n            height: (_b = boundaries.height) !== null && _b !== void 0 ? _b : 0\n        },\n        bottom: {\n            width: (_c = boundaries.width) !== null && _c !== void 0 ? _c : 0,\n            height: boundaries.bottom && refRect.bottom ? boundaries.bottom - refRect.bottom : 0\n        },\n        left: {\n            width: refRect.left && boundaries.left ? refRect.left - boundaries.left : 0,\n            height: (_d = boundaries.height) !== null && _d !== void 0 ? _d : 0\n        }\n    };\n    const sortedAreas = Object.keys(rects)\n        .map((key) => (Object.assign(Object.assign({ key }, rects[key]), { area: getArea(rects[key]) })))\n        .sort((a, b) => b.area - a.area);\n    let filteredAreas = sortedAreas.filter(({ width, height }) => {\n        return width >= target.clientWidth\n            && height >= target.clientHeight;\n    });\n    filteredAreas = filteredAreas.filter((position) => {\n        return allowedPositions\n            .some((allowedPosition) => {\n            return allowedPosition === position.key;\n        });\n    });\n    const computedPlacement = filteredAreas.length > 0\n        ? filteredAreas[0].key\n        : sortedAreas[0].key;\n    const variation = placement.split(' ')[1];\n    // for tooltip on auto position\n    target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${getBsVer().isBs5 ? PlacementForBs5[computedPlacement] : computedPlacement}`);\n    return computedPlacement + (variation ? `-${variation}` : '');\n}\n\nfunction getOffsets(data) {\n    var _a, _b, _c, _d;\n    return {\n        width: data.offsets.target.width,\n        height: data.offsets.target.height,\n        left: Math.floor((_a = data.offsets.target.left) !== null && _a !== void 0 ? _a : 0),\n        top: Math.round((_b = data.offsets.target.top) !== null && _b !== void 0 ? _b : 0),\n        bottom: Math.round((_c = data.offsets.target.bottom) !== null && _c !== void 0 ? _c : 0),\n        right: Math.floor((_d = data.offsets.target.right) !== null && _d !== void 0 ? _d : 0)\n    };\n}\n\n/**\n * Get the opposite placement of the given one\n */\nfunction getOppositePlacement(placement) {\n    const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n\n/**\n * Get the opposite placement variation of the given one\n */\nfunction getOppositeVariation(variation) {\n    if (variation === 'right') {\n        return 'left';\n    }\n    else if (variation === 'left') {\n        return 'right';\n    }\n    return variation;\n}\n\nconst parse = (value, def = 0) => value ? parseFloat(value) : def;\nconst ɵ0 = parse;\nfunction getOuterSizes(element) {\n    const window = element.ownerDocument.defaultView;\n    const styles = window === null || window === void 0 ? void 0 : window.getComputedStyle(element);\n    const x = parse(styles === null || styles === void 0 ? void 0 : styles.marginTop) + parse(styles === null || styles === void 0 ? void 0 : styles.marginBottom);\n    const y = parse(styles === null || styles === void 0 ? void 0 : styles.marginLeft) + parse(styles === null || styles === void 0 ? void 0 : styles.marginRight);\n    return {\n        width: Number(element.offsetWidth) + y,\n        height: Number(element.offsetHeight) + x\n    };\n}\n\n/**\n * Get offsets to the reference element\n */\nfunction getReferenceOffsets(target, host, fixedPosition) {\n    const commonOffsetParent = fixedPosition\n        ? getFixedPositionOffsetParent(target)\n        : findCommonOffsetParent(target, host);\n    return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get offsets to the target\n */\nfunction getTargetOffsets(target, hostOffsets, position) {\n    var _a, _b, _c;\n    const placement = position.split(' ')[0];\n    // Get target node sizes\n    const targetRect = getOuterSizes(target);\n    // Add position, width and height to our offsets object\n    const targetOffsets = {\n        width: targetRect.width,\n        height: targetRect.height\n    };\n    // depending by the target placement we have to compute its offsets slightly differently\n    const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    const mainSide = isHoriz ? 'top' : 'left';\n    const secondarySide = isHoriz ? 'left' : 'top';\n    const measurement = isHoriz ? 'height' : 'width';\n    const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    targetOffsets[mainSide] =\n        ((_a = hostOffsets[mainSide]) !== null && _a !== void 0 ? _a : 0) +\n            hostOffsets[measurement] / 2 -\n            targetRect[measurement] / 2;\n    targetOffsets[secondarySide] = placement === secondarySide\n        ? ((_b = hostOffsets[secondarySide]) !== null && _b !== void 0 ? _b : 0) - targetRect[secondaryMeasurement]\n        : (_c = hostOffsets[getOppositePlacement(secondarySide)]) !== null && _c !== void 0 ? _c : 0;\n    return targetOffsets;\n}\n\nfunction isModifierEnabled(options, modifierName) {\n    var _a;\n    return !!((_a = options.modifiers[modifierName]) === null || _a === void 0 ? void 0 : _a.enabled);\n}\n\nconst availablePositions = {\n    top: ['top', 'top start', 'top end'],\n    bottom: ['bottom', 'bottom start', 'bottom end'],\n    start: ['start', 'start top', 'start bottom'],\n    end: ['end', 'end top', 'end bottom']\n};\nfunction checkPopoverMargin(placement, checkPosition) {\n    if (!getBsVer().isBs5) {\n        return false;\n    }\n    return availablePositions[checkPosition].includes(placement);\n}\nfunction checkMargins(placement) {\n    if (!getBsVer().isBs5) {\n        return '';\n    }\n    if (checkPopoverMargin(placement, 'end')) {\n        return 'ms-2';\n    }\n    if (checkPopoverMargin(placement, 'start')) {\n        return 'me-2';\n    }\n    if (checkPopoverMargin(placement, 'top')) {\n        return 'mb-2';\n    }\n    if (checkPopoverMargin(placement, 'bottom')) {\n        return 'mt-2';\n    }\n    return '';\n}\n\nfunction updateContainerClass(data, renderer) {\n    const target = data.instance.target;\n    let containerClass = target.className;\n    const dataPlacement = getBsVer().isBs5 ? PlacementForBs5[data.placement] : data.placement;\n    if (data.placementAuto) {\n        containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${dataPlacement}`);\n        containerClass = containerClass.replace(/ms-2|me-2|mb-2|mt-2/g, '');\n        containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${dataPlacement}`);\n        containerClass = containerClass.replace(/\\sauto/g, ` ${dataPlacement}`);\n        if (containerClass.indexOf('popover') !== -1) {\n            containerClass = containerClass + ' ' + checkMargins(dataPlacement);\n        }\n        if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n            containerClass += ' popover-auto';\n        }\n        if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n            containerClass += ' tooltip-auto';\n        }\n    }\n    containerClass = containerClass.replace(/left|right|top|bottom|end|start/g, `${dataPlacement.split(' ')[0]}`);\n    if (renderer) {\n        renderer.setAttribute(target, 'class', containerClass);\n        return;\n    }\n    target.className = containerClass;\n}\n\nfunction setStyles(element, styles, renderer) {\n    if (!element || !styles) {\n        return;\n    }\n    Object.keys(styles).forEach((prop) => {\n        let unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n            isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        if (renderer) {\n            renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        element.style[prop] = String(styles[prop]) + unit;\n    });\n}\n\nfunction arrow(data) {\n    var _a, _b, _c, _d, _e, _f;\n    let targetOffsets = data.offsets.target;\n    // if arrowElement is a string, suppose it's a CSS selector\n    const arrowElement = data.instance.target.querySelector('.arrow');\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n        return data;\n    }\n    const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n    const len = isVertical ? 'height' : 'width';\n    const sideCapitalized = isVertical ? 'Top' : 'Left';\n    const side = sideCapitalized.toLowerCase();\n    const altSide = isVertical ? 'left' : 'top';\n    const opSide = isVertical ? 'bottom' : 'right';\n    const arrowElementSize = getOuterSizes(arrowElement)[len];\n    const placementVariation = data.placement.split(' ')[1];\n    // top/left side\n    if (((_a = data.offsets.host[opSide]) !== null && _a !== void 0 ? _a : 0) - arrowElementSize < ((_b = targetOffsets[side]) !== null && _b !== void 0 ? _b : 0)) {\n        (targetOffsets)[side] -=\n            ((_c = targetOffsets[side]) !== null && _c !== void 0 ? _c : 0) - (((_d = data.offsets.host[opSide]) !== null && _d !== void 0 ? _d : 0) - arrowElementSize);\n    }\n    // bottom/right side\n    if (Number((data).offsets.host[side]) + Number(arrowElementSize) > ((_e = targetOffsets[opSide]) !== null && _e !== void 0 ? _e : 0)) {\n        (targetOffsets)[side] +=\n            Number((data).offsets.host[side]) + Number(arrowElementSize) - Number((targetOffsets)[opSide]);\n    }\n    targetOffsets = getClientRect(targetOffsets);\n    // Compute the sideValue using the updated target offsets\n    // take target margin in account because we don't have this info available\n    const css = getStyleComputedProperty(data.instance.target);\n    const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]) || 0;\n    const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]) || 0;\n    // compute center of the target\n    let center;\n    if (!placementVariation) {\n        center = Number((data).offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n    }\n    else {\n        const targetBorderRadius = parseFloat(css.borderRadius) || 0;\n        const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n        center = side === placementVariation ?\n            Number((data).offsets.host[side]) + targetSideArrowOffset :\n            Number((data).offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n    }\n    let sideValue = center - ((_f = targetOffsets[side]) !== null && _f !== void 0 ? _f : 0) - targetMarginSide - targetBorderSide;\n    // prevent arrowElement from being placed not contiguously to its target\n    sideValue = Math.max(Math.min(targetOffsets[len] - (arrowElementSize + 5), sideValue), 0);\n    data.offsets.arrow = {\n        [side]: Math.round(sideValue),\n        [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n    };\n    data.instance.arrow = arrowElement;\n    return data;\n}\n\nfunction flip(data) {\n    data.offsets.target = getClientRect(data.offsets.target);\n    if (!isModifierEnabled(data.options, 'flip')) {\n        data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n        return data;\n    }\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    'viewport', false // positionFixed\n    );\n    let placement = data.placement.split(' ')[0];\n    let variation = data.placement.split(' ')[1] || '';\n    const offsetsHost = data.offsets.host;\n    const target = data.instance.target;\n    const host = data.instance.host;\n    const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n    const flipOrder = [placement, adaptivePosition];\n    flipOrder.forEach((step, index) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        if (placement !== step || flipOrder.length === index + 1) {\n            return;\n        }\n        placement = data.placement.split(' ')[0];\n        // using floor because the host offsets may contain decimals we are not going to consider here\n        const overlapsRef = (placement === 'left' &&\n            Math.floor((_a = data.offsets.target.right) !== null && _a !== void 0 ? _a : 0) > Math.floor((_b = data.offsets.host.left) !== null && _b !== void 0 ? _b : 0)) ||\n            (placement === 'right' &&\n                Math.floor((_c = data.offsets.target.left) !== null && _c !== void 0 ? _c : 0) < Math.floor((_d = data.offsets.host.right) !== null && _d !== void 0 ? _d : 0)) ||\n            (placement === 'top' &&\n                Math.floor((_e = data.offsets.target.bottom) !== null && _e !== void 0 ? _e : 0) > Math.floor((_f = data.offsets.host.top) !== null && _f !== void 0 ? _f : 0)) ||\n            (placement === 'bottom' &&\n                Math.floor((_g = data.offsets.target.top) !== null && _g !== void 0 ? _g : 0) < Math.floor((_h = data.offsets.host.bottom) !== null && _h !== void 0 ? _h : 0));\n        const overflowsLeft = Math.floor((_j = data.offsets.target.left) !== null && _j !== void 0 ? _j : 0) < Math.floor((_k = boundaries.left) !== null && _k !== void 0 ? _k : 0);\n        const overflowsRight = Math.floor((_l = data.offsets.target.right) !== null && _l !== void 0 ? _l : 0) > Math.floor((_m = boundaries.right) !== null && _m !== void 0 ? _m : 0);\n        const overflowsTop = Math.floor((_o = data.offsets.target.top) !== null && _o !== void 0 ? _o : 0) < Math.floor((_p = boundaries.top) !== null && _p !== void 0 ? _p : 0);\n        const overflowsBottom = Math.floor((_q = data.offsets.target.bottom) !== null && _q !== void 0 ? _q : 0) > Math.floor((_r = boundaries.bottom) !== null && _r !== void 0 ? _r : 0);\n        const overflowsBoundaries = (placement === 'left' && overflowsLeft) ||\n            (placement === 'right' && overflowsRight) ||\n            (placement === 'top' && overflowsTop) ||\n            (placement === 'bottom' && overflowsBottom);\n        // flip the variation if required\n        const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        const flippedVariation = ((isVertical && variation === 'left' && overflowsLeft) ||\n            (isVertical && variation === 'right' && overflowsRight) ||\n            (!isVertical && variation === 'left' && overflowsTop) ||\n            (!isVertical && variation === 'right' && overflowsBottom));\n        if (overlapsRef || overflowsBoundaries || flippedVariation) {\n            if (overlapsRef || overflowsBoundaries) {\n                placement = flipOrder[index + 1];\n            }\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n            data.placement = placement + (variation ? ` ${variation}` : '');\n            data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n        }\n    });\n    return data;\n}\n\nfunction initData(targetElement, hostElement, position, options) {\n    if (!targetElement || !hostElement) {\n        return;\n    }\n    const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n    if (!position.match(/^(auto)*\\s*(left|right|top|bottom|start|end)*$/)\n        && !position.match(/^(left|right|top|bottom|start|end)*(?: (left|right|top|bottom|start|end))*$/)) {\n        position = 'auto';\n    }\n    const placementAuto = !!position.match(/auto/g);\n    // support old placements 'auto left|right|top|bottom'\n    let placement = position.match(/auto\\s(left|right|top|bottom|start|end)/)\n        ? position.split(' ')[1] || 'auto'\n        : position;\n    // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n    const matches = placement.match(/^(left|right|top|bottom|start|end)* ?(?!\\1)(left|right|top|bottom|start|end)?/);\n    if (matches) {\n        placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n    }\n    // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n    if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n        placement = 'auto';\n    }\n    placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n    const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n    return {\n        options: options || { modifiers: {} },\n        instance: {\n            target: targetElement,\n            host: hostElement,\n            arrow: void 0\n        },\n        offsets: {\n            target: targetOffset,\n            host: hostElPosition,\n            arrow: void 0\n        },\n        positionFixed: false,\n        placement,\n        placementAuto\n    };\n}\n\nfunction preventOverflow(data) {\n    var _a;\n    if (!isModifierEnabled(data.options, 'preventOverflow')) {\n        return data;\n    }\n    // NOTE: DOM access here\n    // resets the target Offsets's position so that the document size can be calculated excluding\n    // the size of the targetOffsets element itself\n    const transformProp = 'transform';\n    const targetStyles = data.instance.target.style; // assignment to help minification\n    const { top, left, [transformProp]: transform } = targetStyles;\n    targetStyles.top = '';\n    targetStyles.left = '';\n    targetStyles[transformProp] = '';\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    ((_a = data.options.modifiers.preventOverflow) === null || _a === void 0 ? void 0 : _a.boundariesElement) || 'scrollParent', false // positionFixed\n    );\n    // NOTE: DOM access here\n    // restores the original style properties after the offsets have been computed\n    targetStyles.top = top;\n    targetStyles.left = left;\n    targetStyles[transformProp] = transform;\n    const order = ['left', 'right', 'top', 'bottom'];\n    const check = {\n        primary(placement) {\n            var _a, _b, _c, _d;\n            let value = data.offsets.target[placement];\n            // options.escapeWithReference\n            if (((_a = data.offsets.target[placement]) !== null && _a !== void 0 ? _a : 0) < ((_b = boundaries[placement]) !== null && _b !== void 0 ? _b : 0)) {\n                value = Math.max((_c = data.offsets.target[placement]) !== null && _c !== void 0 ? _c : 0, (_d = boundaries[placement]) !== null && _d !== void 0 ? _d : 0);\n            }\n            return { [placement]: value };\n        },\n        secondary(placement) {\n            var _a, _b, _c, _d, _e, _f, _g, _h;\n            const mainSide = placement === 'right' ? 'left' : 'top';\n            let value = data.offsets.target[mainSide];\n            // escapeWithReference\n            if (((_a = data.offsets.target[placement]) !== null && _a !== void 0 ? _a : 0) < ((_b = boundaries[placement]) !== null && _b !== void 0 ? _b : 0) && placement !== 'right') {\n                value = Math.min((_c = data.offsets.target[mainSide]) !== null && _c !== void 0 ? _c : 0, ((_d = boundaries[placement]) !== null && _d !== void 0 ? _d : 0) - data.offsets.target.height);\n            }\n            if (((_e = data.offsets.target[placement]) !== null && _e !== void 0 ? _e : 0) > ((_f = boundaries[placement]) !== null && _f !== void 0 ? _f : 0) && placement === 'right') {\n                value = Math.min((_g = data.offsets.target[mainSide]) !== null && _g !== void 0 ? _g : 0, ((_h = boundaries[placement]) !== null && _h !== void 0 ? _h : 0) - data.offsets.target.width);\n            }\n            return { [mainSide]: value };\n        }\n    };\n    order.forEach((placement) => {\n        const side = ['left', 'top', 'start'].indexOf(placement) !== -1 ? check['primary'] : check['secondary'];\n        data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), side(placement));\n    });\n    return data;\n}\n\nfunction shift(data) {\n    var _a;\n    const placement = data.placement;\n    const basePlacement = placement.split(' ')[0];\n    const shiftVariation = placement.split(' ')[1];\n    if (shiftVariation) {\n        const { host, target } = data.offsets;\n        const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n        const side = isVertical ? 'left' : 'top';\n        const measurement = isVertical ? 'width' : 'height';\n        const shiftOffsets = {\n            start: { [side]: host[side] },\n            end: {\n                [side]: ((_a = host[side]) !== null && _a !== void 0 ? _a : 0) + host[measurement] - target[measurement]\n            }\n        };\n        data.offsets.target = Object.assign(Object.assign({}, target), {\n            [side]: (side === shiftVariation ? shiftOffsets.start[side] : shiftOffsets.end[side])\n        });\n    }\n    return data;\n}\n\nclass Positioning {\n    position(hostElement, targetElement /*, round = true*/) {\n        return this.offset(hostElement, targetElement /*, false*/);\n    }\n    offset(hostElement, targetElement /*, round = true*/) {\n        return getReferenceOffsets(targetElement, hostElement);\n    }\n    positionElements(hostElement, targetElement, position, appendToBody, options) {\n        const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n        const _position = MapPlacementInToRL[position];\n        const data = initData(targetElement, hostElement, _position, options);\n        if (!data) {\n            return;\n        }\n        return chainOfModifiers.reduce((modifiedData, modifier) => modifier(modifiedData), data);\n    }\n}\nconst positionService = new Positioning();\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n    const data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n    if (!data) {\n        return;\n    }\n    const offsets = getOffsets(data);\n    setStyles(targetElement, {\n        'will-change': 'transform',\n        top: '0px',\n        left: '0px',\n        transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n    }, renderer);\n    if (data.instance.arrow) {\n        setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n    }\n    updateContainerClass(data, renderer);\n}\n\nclass PositioningService {\n    constructor(ngZone, rendererFactory, platformId) {\n        this.update$$ = new Subject();\n        this.positionElements = new Map();\n        this.isDisabled = false;\n        if (isPlatformBrowser(platformId)) {\n            ngZone.runOutsideAngular(() => {\n                this.triggerEvent$ = merge(fromEvent(window, 'scroll', { passive: true }), fromEvent(window, 'resize', { passive: true }), of(0, animationFrameScheduler), this.update$$);\n                this.triggerEvent$.subscribe(() => {\n                    if (this.isDisabled) {\n                        return;\n                    }\n                    this.positionElements\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        .forEach((positionElement) => {\n                        positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, this.options, rendererFactory.createRenderer(null, null));\n                    });\n                });\n            });\n        }\n    }\n    position(options) {\n        this.addPositionElement(options);\n    }\n    get event$() {\n        return this.triggerEvent$;\n    }\n    disable() {\n        this.isDisabled = true;\n    }\n    enable() {\n        this.isDisabled = false;\n    }\n    addPositionElement(options) {\n        this.positionElements.set(_getHtmlElement(options.element), options);\n    }\n    calcPosition() {\n        this.update$$.next();\n    }\n    deletePositionElement(elRef) {\n        this.positionElements.delete(_getHtmlElement(elRef));\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n}\nPositioningService.ɵfac = function PositioningService_Factory(t) { return new (t || PositioningService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2), ɵngcc0.ɵɵinject(PLATFORM_ID)); };\nPositioningService.ɵprov = ɵɵdefineInjectable({ factory: function PositioningService_Factory() { return new PositioningService(ɵɵinject(NgZone), ɵɵinject(RendererFactory2), ɵɵinject(PLATFORM_ID)); }, token: PositioningService, providedIn: \"root\" });\nPositioningService.ctorParameters = () => [\n    { type: NgZone },\n    { type: RendererFactory2 },\n    { type: Number, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PositioningService, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.RendererFactory2 }, { type: Number, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, null); })();\nfunction _getHtmlElement(element) {\n    // it means that we got a selector\n    if (typeof element === 'string') {\n        return document.querySelector(element);\n    }\n    if (element instanceof ElementRef) {\n        return element.nativeElement;\n    }\n    return element !== null && element !== void 0 ? element : null;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { PlacementForBs5, Positioning, PositioningService, checkMargins, positionElements };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}